#inclure "ç.h"

entier principale(entier argc, caractère* argv[]) {
	taille_t i = 0;

	FICHIER *fichier, *temporaire;
	caractère* chemin_du_fichier = NUL;
	caractère constant* suffixe = ".c.fr";

	entier succes_de_la_traduction;
	caractère* chemin_de_la_traduction;

	entier succes_de_la_compilation;

	si (argc == 1) {
		retourner 0;
	}

	pour (i = 1; i < (taille_t)argc; ++i) {
		chemin_du_fichier = argv[i];

		si (strcmp(&chemin_du_fichier[strlen(chemin_du_fichier)-strlen(suffixe)], suffixe) != 0) {
			fprintf(stderr, "Type de fichier non supporté %s\n", chemin_du_fichier);
			retourner 1;
		}

		/* J4OUVRE */
		fichier = fopen(chemin_du_fichier, "r");
		si (fichier == NUL) {
			fprintf(stderr, "Le fichier %s n'a pas pu etre ouvert\n", chemin_du_fichier);
			retourner 1;
		}

		/* set the name of the fichier to create */
		chemin_de_la_traduction = malloc(strlen(chemin_du_fichier) * taille de(caractère));
		memcpy(chemin_de_la_traduction, chemin_du_fichier, strlen(chemin_du_fichier));
		chemin_de_la_traduction[strlen(chemin_du_fichier)-3] = '\0';

		/* create the fichier to write in */
		temporaire = fopen(chemin_de_la_traduction, "w");
		si (temporaire == NUL) {
			fprintf(stderr, "Failed to create a new fichier.\n");
			retourner 8;
		}

		/* read words from the fichier */
		succes_de_la_traduction = ccdille_traduire_fichier(fichier, temporaire);
		si (succes_de_la_traduction != 0) {
			retourner succes_de_la_traduction;
		}

		/* JE FERME */
		fclose(fichier);
		fclose(temporaire);
	}

	succes_de_la_compilation = execl("/usr/bin/cc", "cc", "-o", "a.sortie", chemin_de_la_traduction, NUL);

	free(chemin_de_la_traduction);

	retourner succes_de_la_compilation;
}

entier ccdille_traduire_fichier(FICHIER* entree, FICHIER* sortie) {
	caractère tampon[TAILLE_DU_TAMPON];
	entier c;
	entier succes_de_la_traduction;
	taille_t longueur;
	taille_t ecrit;

	longueur = 0;
	pour (;;) {
		c = fgetc(entree);

		si (c == ' ' || c == '\n' || c == '\t' || c == '\r' || c == '(' || c == ')' || c == '/' || c == '*' || c == ';' || c == EOF) {
			succes_de_la_traduction = ccdille_traduire_mot((caractère*)tampon, &longueur);
			si (succes_de_la_traduction || c == EOF) {
				ecrit = fwrite((vide*)tampon, taille de(caractère), longueur, sortie);
				si (ecrit < longueur) {
					retourner 6;
				}

				si (c == EOF) {
					casser;
				}

				tampon[0] = (caractère) c;
				ecrit = fwrite((void*)tampon, taille de(caractère), 1, sortie);

				si (ecrit < 1) {
					retourner 7;
				}

				longueur = 0;
				continuer;
			}
		}

		tampon[longueur] = (caractère) c;
		++longueur;
	}

	retourner 0;
}

entier ccdille_traduire_mot(caractère* mot, taille_t* longueur) {
	taille_t i;
	énumération ccdille_comparaison_de_chaine_de_caractere_resultat resultat;
	structure mot_cle_francais_t mot_cle_francais;
	pour (i = 0; i < taille de(mot_cles_francais)/taille de(*mot_cles_francais); i++) {
		mot_cle_francais = mot_cles_francais[i];
		resultat = ccdille_comparaison_de_chaine_de_caractere(mot, *longueur, mot_cle_francais.mot, strlen(mot_cle_francais.mot));
		commuter (resultat) {
		cas CCDILLE_CORRESPONDANCE:
			*longueur = strlen(mot_cle_francais.traduction);
			memcpy(mot, mot_cle_francais.traduction, *longueur);
			retourner 1;
		cas CCDILLE_PREFIXE:
			retourner 0;
		cas CCDILLE_PAS_DE_CORRESPONDANCE:
			casser;
		/* mdr ya pas de par défaut */
		}
	}

	retourner 1;
}

taille_t ccdille_min(taille_t a, taille_t b) {
	retourner a <= b ? a : b;
}

énumération ccdille_comparaison_de_chaine_de_caractere_resultat ccdille_comparaison_de_chaine_de_caractere(caractère constant* a, taille_t taille_de_a, caractère constant* b, taille_t taille_de_b) {
	taille_t i;
	pour (i = 0; i < ccdille_min(taille_de_a, taille_de_b); i++) {
		si (a[i] != b[i]) {
			retourner CCDILLE_PAS_DE_CORRESPONDANCE;
		}
	}
	si (taille_de_a == taille_de_b) {
		retourner CCDILLE_CORRESPONDANCE;
	}
	si (taille_de_a > taille_de_b || b[i] != ' ') {
		retourner CCDILLE_PAS_DE_CORRESPONDANCE;
	}
	retourner CCDILLE_PREFIXE;
}
